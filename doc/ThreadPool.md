# 一、实现功能
1. 多种工作模式 (```enum class```)
   - ```FIXED_THREAD```: 线程数量固定 (线程池开始时给定的参数，但是不能超过超过硬件支持的数量，超过则改为硬件支持的数量) —— 不会随任务多少而改变。
   - ```MUTABLE_THREAD```: 线程数量可变 (线程池开始时给定的参数作为下限，其二倍作为上限；但是不能超过超过硬件支持的数量，超过则改为硬件支持的数量；如果上下限全部超过，则行为等同于 ```FIXED_THREAD``` 模式) —— 当任务数量超过线程数量时，增加线程 (不超过线程上限)；当线程超过一定时间无法接到任务时，释放线程 (不低于线程下线)。
2. 任务优先级 (```priority_queue``` + ```pair```)
    - 线程优先获取更高优先级任务 （仿函数设置 ```priority_queue``` 比较函数）。
    - 任务优先级相同时，线程优先获取先进任务队列的任务 (严格弱排序)。
3. 任务提交超时时长 (```condition_variable.wait_for()```)
	- 多种设置超时时长方式。
4. 可接受任意返回类型和任意参数的任务函数 (将有返回值有参函数转换为无返回值无参函数)。
5. 有限/无限长度任务队列 (当任务队列有限时，才会出现任务提交超时的判定)。
6. 有限线程数量 (不能超过 ```std::thread::hardware_concurrency()```)。
7. 统一的工作线程入口 (仿函数的 ```operator()```)。
8. 可手动关闭线程池，也可自动关闭线程池 (析构函数会自动调用关闭线程池方法，并且会判断线程池是否已经被关闭，如已关闭，析构函数不会执行任何操作)。
9. 线程池关闭后，会等待任务队列所有任务结束 (两个条件，线程池关闭 ```bool``` 变量 + 任务队列为空)，且阻止用户继续提交任务。
10. 实时更新并反馈任务队列以及线程队列状态 (原子变量)。
11. 多种线程池配置相关接口。
	- 任务队列长度。
    	- ```void setTaskMaxAmount(size_t);```
    	- ```size_t getTaskMaxAmount();```
	- 任务提交超时时长。
    	-  ```void setTaskTimeoutByMilliseconds(std::chrono::milliseconds);```
    	-  ```void setTaskTimeoutBySeconds(std::chrono::seconds);```
	- 任务优先级。
    	- ```size_t getTaskPriority();```
    	- ```void setTaskPriority(size_t);```
	- 线程池工作模式。
    	- ```void showThreadPoolWorkMode();```

---
# 二、遇到的问题及解决方案
## 问题一: 如何将不同类型、不同参数的函数存放在同一个任务队列？
> **问题详述**: 不可能限制用户提交的任务函数的类型及参数，所以线程池执行的任务可能含有不同的返回值，拥有不同的参数。但是不可能将每一种情况都设置一种对应的任务队列，所以需要使用一种统一方式来存放各种不同类型的任务函数。

> **解决方案**: 首先通过模板函数和可变参数来获取不同返回值和不同参数的任务函数；接着通过 bind 函数将任务函数和其参数绑定在一起，打包成一个新的有返回值的无参函数（需要使用完美转发，保证其左右值属性）；再然后用智能指针指向打包好的函数（因为有可能需要在主线程中获取子线程的结果，所以需要先使用 packaged_task 打包，方便获取其 future 从而得到返回结果），这也方便后续 lambda 函数的捕捉；由于之前已经通过 packaged_task 打包过，可以通过其返回的 future 获得返回值，所以就不需要在考虑返回值的事情。因为可以直接通过使用智能指针执行函数（类似使用函数指针的方式），所以可以通过 lambda 函数来操作该指针（该 lambda 函数是一个无参无返回值的函数），并将该 lambda 函数打包为一个新的函数，并存放到任务队列中。

```cpp
int add(int a, int b) {
	std::cout << a << " " <<  b << std::endl;
	return a + b;
}

int main() {
	
	// step 1	-	有返回值有参函数 --> 有返回值无参函数
	std::function<int()> new_func = std::bind(add, 2, 3);
	std::cout << new_func() << std::endl << std::endl;

	// step 2	-	智能指针指向在线程用的任务函数
	auto task_ptr = std::make_shared<std::packaged_task<int()>>(new_func);
	auto return_future = (*task_ptr).get_future();
	// (*task_ptr)();  通过智能指针执行函数

	// step 3	-	有返回值无参函数 --> 无返回值无参函数
	std::function<void()> warpper_func = [task_ptr]() {
		(*task_ptr)();  // 通过智能指针执行函数
	};

	// step 4	-	入队
	warpper_func();  // 使用该函数就等于使用智能指针指向的任务函数
	std::cout << return_future.get() << std::endl;  // 获取返回值

	return 0;
}
```

## 问题二: 如何将工作线程类转换成线程？
> **问题详述**: 由于需要设置一些线程相关的属性（例如线程 ID、所属线程池等等），所以不能单纯的使用 ```C++11``` 提供的 ```thread```，需要构造一个工作线程类。如果让存储线程的容器，存储一个工作线程类对象，很多操作会变得非常复杂，所以需要设计一个既可以存储线程属性，又可以让操作简单的设计。

> **解决方案**: 通过仿函数实现，而存储线程的容器依旧是存储 ```thread```。设计一个工作线程类，并重载 ```operator()```，这样既可以通过这个仿函数产生一个对象，并操作该工作线程的属性，也可以让所有的线程都拥有同样执行函数 ```operator()```，并在该函数中执行其他的任务函数。通过相同的执行函数，也可以更容易的设计临界区。

## 问题三: 如何设计线程池的自动关闭和手动关闭？
> **问题详述**: 为了防止代码复用，一开始的设计是设置一个主动关闭线程池的接口，并且析构函数中会调用该函数，以防止用户忘记关闭线程池。但是用户手动关闭线程池之后，此时所有的子线程已经被回收，如果析构函数再次调用次函数，则会抛出异常 —— ```Invalid argument```，使用已经被释放的线程。

> **解决方案**: 设置一个 ```bool m_close``` 变量，检测线程池是否已经被关闭，如果已经被关闭，则直接跳过本次执行。通过设置该变量还可以做到，在线程池关闭后，拒绝用户继续提交新的任务。

## 问题四: 如何在关闭线程池之后等待所有任务队列任务结束，而不是直接结束？
> **问题详述**: 如果仅仅是判断线程池是否关闭，那么在设置关闭线程池后，即使任务队列中依然存在任务，剩下的任务不会被执行，而是会直接退出。

> **解决方案**: 判断条件，不仅要检测线程池是否关闭，还需要检测任务队列是否为空。在线程池关闭之后，由于主线程会等待子线程结束，才会最终结束，可以要求子线程将所有任务队列中的任务执行完毕后再退出。

## 问题五: 如何设置优先级任务队列？
> **问题详述**: 优先级任务队列，需要满足优先执行优先级最高的任务、同优先级的时候满足先进先出的特性。

>> **解决方案一**: 考虑到每一个任务都有一个优先级，可以考虑使用 ```map```(提供有序的序列，即按压入顺序，可实现先进先出) 将二者结合，但是 ```map``` 执行效率很低，而且每次需要遍历一遍，以找到优先级最高的任务。
> 
>> **解决方案二**: 通过 ```pair``` 将任务和任务优先级结合，再通过优先级队列选择优先级最高的任务执行，并且可以通过将优先级队列设置成**严格弱排序**以满足同优先级时先进先出。

## 问题六: 如何解决类中的自定义优先级队列的比较函数？-----
> **问题详述**: 优先级任务队列，使用 ```pair<Task, priority>``` 包含任务函数以及任务优先级，并通过 ```priority_queue``` 来继续排序，但是任务函数没有办法进行比较，需要自行设置 ```priority_queue``` 的比较函数。然而 ```C++``` 的 ```auto``` 不能用于非静态成员变量，且 ```C++``` 只能将函数指针传给静态成员，所以常规的比较函数的设置并没有办法使用。

```cpp
auto cmp = [](std::pair<T, size_t>& a, std::pair<T, size_t>& b) {
	return a.second < b.second;
}

bool cmp (std::pair<T, size_t>& a, std::pair<T, size_t>& b) {
	return a.second < b.second;
}
```

> **解决方案**: 使用仿函数，由于 C++ 构造函数在构造对象时，会优先调用内部成员的构造函数，而仿函数就是类似函数的类。所以使用 priority_queue 配合仿函数

## 问题七: 如何回收多余的线程时，子线程如何确定自己在线程队列中的位置？
> **问题详述**: 如果使用 ```vector``` 存放线程，在第一次回收线程的时候，可以通过静态成员 ```m_threads_id``` 给每个线程设置 ```m_id``` 来确定自己的位置，但是当 ```vector``` 释放掉某些线程后，后续线程的位置提前，就需要修改后续线程的 ```m_id```，并且还需要修改 ```m_threads_id```，以防又动态添加线程后 ```m_threads_id``` 超出 ```vector``` 的范围。

> **解决方案**: 改用 ```unordered_map``` 来存放线程，由于 ```key-value``` 结构，可以将线程 ```id``` 作为 ```key```，线程本身作为 ```value``` 进行存放。此时无需考虑静态成员 ```m_threads_id``` 是否会超出范围，也不用对其余线程的 ```m_id``` 进行修改，可以保证 ```m_id``` 是唯一的。

## 问题八: 如何在回收多余的线程时，确保主线程结束不会影响该子线程？
> **问题详述**: 回收线程的过程需要在子线程中自动回收（毕竟用户只用创建线程池，然后将通过线程池接口提交任务，子线程对用户是透明的），但是子线程将自己从线程队列释放后，主线程将不会等待该子线程任务结束，并抛出异常 ```terminate called without an active exception```。

> **解决方案**: 子线程超过一定时间没有接到任务后就需要将自己回收，此时可以通过 ```detach()``` 方法将自己与主线程分离，然后主线结束时，就不会考虑该子线程，此后再将线程队列中 ```key``` 值为自身的 ```m_id``` 的 ```undered_map``` 索引销毁。<br>缺点: 事实上子线程并没真正被回收，直到主线程结束时，由运行时库负责清理与子线程相关的资源。

## 问题九: 如何保证实时反馈任务队列和线程队列状态时不会进入死锁状态？
> **问题详述**: 由于整个线程池只拥有一把互斥锁，所以需要将整个线程池当作临界资源。每次操作线程池时都需要将线程池上锁，但是设置的获取线程池状态的方法中也需要将线程池上锁（防止状态改变），所以就会进入死锁状态 —— 线程在锁定线程池的时候，要求调用获得线程池状态的方法，但是该方法同样需要获取互斥锁权限。

>> **解决方案一**: 由于是对整个线程池上锁，所以其他线程无法对线程池进行操作。换句话说就是可以不通过类提供的函数，直接通过容器 ```size()``` 方法来获取。<br>**缺点**: 这样会显的操作比较凌乱（又是通过类的方法，又是通过容器 ```size()``` 方法）。
>
>> **解决方案二**: 通过原子类型变量，一方面减少了对函数的调用（减少函数入栈的消耗），另一方面原子类型变量使用起来更为便捷。<br>**缺点**: 是次队列有更新的时候，都需要手动更新原子变量。

---
# 三、改进
## 1. 任务在队列中超过一定时间没有被执行时的反馈
**情形描述**: 当低优先级任务提交到任务队列后，可能一直有高优先级任务被推送到任务队列，此时可能会出现低优先级任务长时间无法被子线程执行。此时需撤销该任务，并提示用户。

**可能的方案**: 任务队列，再添加一个值，```std::chrono::steady_clock::now``` 记录任务提交时间。然后每隔一段时间锁定线程池，判断任务队列中是否有函数超过一定时间没有被执行，有的话将该任务函数撤销，并提示用户。

## 2. 带有返回值的任务提交失败时的反馈
**情形描述**: 当任务提交失败的时候，并没有一个很好的提示，告诉用户是否是自己的任务提交失败，此时可能存在用户误认为任务提交成功，强行使用返回的 ```future```，以获取任务函数的返回值。

**可能的方案**: 线程池提交任务的函数，返回一个 ```pair```。第一个参数是返回的 future，第二个返回的是一个 bool 值，用户可以先通过判断是否成功返回，在决定是否可以取值。（实际和 try catch 差不多，不是很好的方案）

## 3. 线程池运行时更换线程池工作模式
**情形描述**: 线程池工作的过程中，从 ```FIXED_THREAD``` 模式转换成 ```MUTABLE_THREAD``` 模式，或者从 ```MUTABLE_THREAD``` 模式转换成 ```FIXED_THREAD``` 模式。

**可能的方案**: 
- ```MUTABLE_THREAD``` 模式转换成 ```FIXED_THREAD``` 模式: 需要给定线程数量，如果该值超过硬件所支持的最大线程数量，则直接设定为硬件支持的最大线程数量。如果当前线程数量少于目标值，则增加相应的线程；如果多于目标值，则将最先空闲的线程回收（如果存在多个这样的线程，则按其 ```m_id``` 从低到高依次回收）。
- ```FIXED_THREAD``` 模式转换成 ```MUTABLE_THREAD``` 模式: 需要给定线程数量下限，其上限为给定数值的二倍，如果该超过硬件所支持的最大线程数量，则直接设定为硬件支持的最大线程数量。如果原始线程数量超过 ```MUTABLE_THREAD``` 模式的最大值，则回收线程；如果原始线程数量少于 ```MUTABLE_THREAD``` 模式的最小值，则增加线程到其最低限制。

---
# 四、编译参数（线程池可以单独编译使用）
```cpp
"args": [
    "-g",
    "${file}",
    "-lpthread",
    "-std=c++11",
    "-fdiagnostics-color=always",
    "-o",
    "${fileDirname}/${fileBasenameNoExtension}"
]
```